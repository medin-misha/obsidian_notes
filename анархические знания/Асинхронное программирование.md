Как привило мы пишем код в синхронной манере. Записать в переменную что то пройтись циклом и записать что то куда то. Программа будет выполняться шаг за шагом и следуйщий шаг не будет выполнен если программа зависнит на предыдущем шаге.

К стати если мы застрянем на каком-то из шагов это будет называться **блокировка кода**.

Есть несколько способов обхода блокировки кода, те же самые [[Треды|треды]], но треды используют слижком много ресурсов. Этот способ отлично подходит для I\O но не более. Так же треды выглядят очень страшно и громоздко.

Так же можно использовать [[процессы и потоки с точки зрения python|процессы]] и тогда на каждое ядро процессора будет вешаться процесс который будет выполнять операцию. Тоже интересное решение.

## синхронная программная модель
>**Синхронная программная модель** – это программная модель, когда потоку назначается одна задача и начинается выполнение. Когда завершено выполнение задачи тогда появляется возможность заняться другой задачей. В этой модели невозможно останавливать выполнение задачи чтобы в промежутке выполнить другую задачу. Давайте обсудим как эта модель работает в одно и многопоточном сценарии.

Модель выполнения **шаг за шагом**
### однопоточность
>**Однопоточность** – если мы имеем несколько задач, которые надлежит выполнить, и текущая система предоставляет один поток, который может работать со всеми задачами, то он берет поочередно одну за другой и процесс выглядит так

THREAD1 --- task1->task2->task3-> task4->

то есть однопоточный режим выполняет задачи в порядке очереди.
Так же мы можем создать новые потоки и делигировать на них часть задач:


THREAD1 --- task1
THREAD2 --- task2
THREAD3 --- task3
THREAD4 --- task4

## асинхронная модель программирования
> **Асинхронная модель программирования** – в отличии от синхронной программной модели, здесь поток однажды начав выполнение задачи может приостановить выполнение сохранив текущее состояние и между тем начать выполнение другой задачи.

THREAD1 --- task1->task2->task3-> task4->task3-> task1 -> task4-> task1

Так же тут имеет место быть многопоточность:
THREAD1 --- task1->task2->task6-> task4->task3-> task1 -> task4-> task6
THREAD2 --- task7->task2->task3-> task4->task3-> task7 -> task4-> task7
THREAD3 --- task1->task2->task5-> task4->task3-> task5 -> task4-> task5