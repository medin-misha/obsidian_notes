В [[python]] есть поддержка необязательных аннотаций типов. 

**Аннотация типов** - это конструкция которая позволяет не сложным и явным образом определять тип переменной. Использование аннотации типов позволяет IDE делать тебе лучшие подсказки и позволяет некоторым инструментам более просто работать.

Я буду показывать на примере [[Fast API]] по скольку он основан на аннотации типов.

```python
def get_full_name(first_name, last_name):  
    full_name = first_name.title() + " " + last_name.title()  
    return full_name  
  
print(get_full_name(first_name="михаил", last_name="мединский"))

## Михаил мединский
```
этот код получает на вход 2 строки и преобразует первый символ в верхний регистр. По итогу выводиться результат `Михаил Мединский`. 

Тут вполне понятно какая функция отвечает за преобразование но на момент определения функции нужно было над этим подумать. Предположим что ты забыл или не знал что такая функция как `title()` существует (как я). И попробую воспользоваться подсказкой IDE но она не будет ничего выводить по тому что IDE не понимает какой тип данных будет у переменных `last_name` & `first_name`. Для решения этой зарачи придумали аннотацию типов.
```python
def get_full_name(first_name: str, last_name: str):
```
сразу выделю несколько плюсов такого кода:
1. на глаз видно какой тип должен быть у переменной
2. IDE даёт подсказки
3. когда ты попыташься закинуть в переменную не тот тип тебя предупредит об этом IDE
4. стороннему разроботчику будет проще разобраться в этой дресне
5. так же ты получаешь и проверку ошибок за счёт IDE, если ты проанатировал переменную как `str` и пытаешься к строке прибавить число 50, твоё IDE сразу напомнит что ты програмируешь на питоне.
ты можешь обьявить и другие типы:
- int
- bool
- float
- str
- bytes
и так далее.

Так же существуют и другие Generic(обобщённые) типы данных
- dict
- list
- set
- tuple
эти типы данных могут содержать в себе любые типы данных и обьекты их типизировать немного сложнее. Тут придёться использовать модуль из стандартной библиотеки `typing`
```python
from typing import List  
def printing_items(items: List[str]):  
    for item in items:  
        print(item)
```

`items:List[str]` - означает то что items это список состоящий из строк.
`[str]` в этом контексте будет называться параметром типов.

тоже самое можно сделать и с tuple, set, dict
tuple & set
```python
from typing import Tuple  
def items_generator(items: Tuple[int, int, str]):  
    for item in items:  
        yield item
```
тут мы сказано что кортеж должен состоять строго из 3х елементов не больше не меньше. Именно в таком порядке как заданы параметры типов.

dict
```python
from typing import Dict  
def products_prices(prices: Dict[str, float]):  
    for item, price in prices:  
        yield item, price
```
тут `Dict[str, float]` означает то что:
- ключи в dict будут с типом str
- значения будут с типом float


так же можно сказать что значение не обязательно.
```python
from typing import Optional
def say_hi(name: Optional[str] = None):
    if name is None:
        print("hi")
        return
    print(f"hi, {name}")
```
`Optional[str] = None` важно указывать "= None" по тому что типизация-типизацией но будет ошибка по тому что если ты не передал в переменную что то будет грусно.

Классами тоже можно типизировать:
```python
class Product:  
    def __init__(self, name: str, price: int):  
        self.name = name  
        self.price = price  
  
product: Product = Product(name="name", price=123)
```
тут мы сказали что переменная `product` будет обьектом класса `Product`