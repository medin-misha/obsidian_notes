декораторы нужны для того что бы изменить функцию 


```python
def timer(func:Callable) -> Any:   
    def wrapped_func(*args, **kwargs):  
	    start_at = time.time()   
  
        result = func(*args, **kwargs)  
  
        end_at = time.time()  
  
        print(f" time  {end_at - start_at}")  
  
        return result  
      
    return wrapped_func  
  
  
@timer  
def cubes_sum(numbers:int ) -> int:  
	...
  
  
  

 

# и мы видим результат работы функции wrapper_func которая в себе запустила функцию cubes_sum которую мы задекорировали  
  
print(cubes_sum(3))
```

>==**timer**== - __декоратор который замеряет время работы функциии    возвращяет wrapped_func который на самом деле вызываеться вместо функции которая подаёться как оргумент_  timer это [[функция высшего порядка]]

## что делает timer 
1. wrapped_func с оргументами **args** **kwargs**
2. возвращяет функцию wrapped_func 
## что делает wrapper 
 1. фиксирует время до начала функции и сохраняет в переменную в `start_at`
 2. запускает функцию и сохраняет результат её работы в переменную `result`
 3. фиксирует время после работы функции в переменную `end_at`
 4. распечатывает время работы функции по вормуле `start_at - end_at`
 5. возвращяет результат работы

### что происходит при вызове задекорированной функции cubes_sum
1. мы подаём `cubes_sum` функцию декоратору 
2.  когда функция`cubes_sum`вызываеться в коде то вызываеться timer который создаёт и возвращяет `wrapped_func`
3. вызываеться `wrapped_func` и в неё передаёться теще оргументы которые мы передали при вызове то есть `int(3)`
4. и результат работы `wrapped_func` возвращяеться пользователю

cubes_sum это [[функция (обьект) первого класса]]



> так же стоит заметить если мы хотим декорировать нескольками декораторами функцию то важен порядок декорирования


[[python]]