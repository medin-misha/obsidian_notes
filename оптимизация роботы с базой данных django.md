q# базовые инструменты и другая херотень
## индксы
	тут достаточно указать в [[поля]] по которым нужно будет вести 
	поиск `db_index = True`
```python
	class model(models.Model):
		name = models.CharField(null=False, blank=False, max_length = 100, db_index=True)
```
>оно ускоряет поиск по конкретному полю в БД за счёт того что создаёт
>так сказать пометку для себя типо *ага по этому поле ведёться поиск так 
>что запишука я его что бы не тратить время на поиск*

## транзакции
>[[транзакции в django]] позволяют при ошибке откатить действия с бд
>назад и тем самым спасти нас от ненужных проблемм типо неполного
>создания\обновления модели

### ситуация 

>У нас есть [[django model]] которая связана с другой моделью и создаёться
>с другой моделью одновременно (одна не может существовать
>без другой) и при создании произошла ошибка и всё у нас первая модель 
>не может быть без второй, и мы получаем не корректною работу приложки

транзакиции же убирают эту проблемму за счёт того что если в функции ошибка то база данных откатываеться до работы этой функции или блока кода. 

## частичная загрузка информации о сущностях
если я хочу загрузить только определённые поля то можно использовать
`objects.values("pk", "name", "huyo", "moyo")`
![[Pasted image 20231223213132.png]]


`objects.values_list("pk", "name", flat = False)`
![[Pasted image 20231223213403.png]]


`objects.values_list("pk", "name", flat = True)`
![[Pasted image 20231223213510.png]]


`objects.defer("field1", "field2", "field3").all()`
этот метод не загружает выбраные поля, если они понадобяться то будет
использовата ленивая загрузка тут стоит помнить про [[N+1]]
ИЛИ
есть метод 
`object.only("id", "name").all()` 
тут загружаються только выбранные поля. по сути это тот же defer
но он принимает поля которые нужно загружать а не которые не нужны

## Bulk_Create & Bulk_Update
у нас есть список из каких то елементов
и нам будет легче создать все модели за один запрос а не за N запросов
тут та и нам помогут bulk_create & bulk_update
```python
products = [
            ProductImages(
                    product = self.object,
                    image = img
                )
            for img in form.files.getlist("image")
        ]
        Product.objects.bulk_create(products)
```
в `products` создаёться список елементов и в строке 
`Product.objects.bulk_create(products)` мы создаём все елементы 1дной пачкой. Bulk_Update работает также

## select/prefetch  _related
По умолчанию [[django]] не загружает связную модель а использует **ленивую загрузку** которая загружает по мере необходимости делая запрос в базу данных каждый раз когда связный объект нужен что может привести к проблеме [[N+1]]

Что бы это исправить есть методы
- select_related - оно используется для полей `OneToOne`, `ForeignKey,` и `related_name` 
	К примеру, если есть запрос `Author.objects.select_related('book').get(id=1)`, Django выполнит SQL-запрос, который получит все данные об авторе и его книгах одним запросом. Это может быть очень эффективно, если есть необходимость получить связанные данные, так как это уменьшает количество запросов к базе данных.


- prefetch_related  - оно используеться для полей ManyToMaty
	В случае `Author.objects.prefetch_related('book').get(id=1)`, Django сначала выполнит запрос для получения автора, а затем отдельный запрос для получения всех его книг. Затем Django «соединит» эти данные в Python, чтобы предоставить удобный способ доступа к связанным данным.



