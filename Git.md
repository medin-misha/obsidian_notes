
Git это система контроля версий. Git умеет в командную работу. Система контроля версий нужна для контроля над версиями проэкта и обеспечения командной работы.

Git - это самая крутая система контроля версий с открытым исходным кодом + он компактен и быстро-работающий + система веток для отдельных задач + можно копировать ВЕСЬ репозиторий и синхронизировать изменения.

#  как выглядит работа с git
для начала нам нужен репозиторий(проэкт) с которым мы будем работать в git. Он будет таким https://github.com/sortedmap/git-basics.

Что бы скопировать сам проэкт нужно использовать команду clone
```git
git clone https://github.com/sortedmap/git-basics
```
и в той директории в которой мы находимся создаёться папка с вот такими фалами
![[Pasted image 20240825201950.png]]
всё прошло успешно. Если написать команду `git status` мы сможем увидеть инфу о текущей ветке и какой ветке она соотвецтвует. Так же информацию о коммитах.

Если мы что то изменим в index.html или в любом другом файле этого репозитория и введём `git status` то мы увидим что изменён какой то файл и указка на сам файл
![[Pasted image 20240825202505.png]]
теперь если мы напишем 
```
git add .
git commit -m "описание изменений"
```
то при вводе `git status` нам скажут что наша ветка опережает orgigin/master на 1 коммит
# работа с git в командной строке
Если мы зайдём в рандомную папку и напишем там `git status` то нас вежливо проинформируют ФАТАЛЬНОЙ ОШИБКОЙ что git репозиторий не найден. Что бы его создать нужно написать `git init`
теперь у нас инициализирован пустой репозиторий, а в `.git` директории. Это директория которая содержит в себе всю историю изменений в проэкте. 

Если мы добавим директорию в которой есть папка .git что нибуть и напишем `git status` то нам скажут что найден новый файл.

на этом моменте нужно сохраниться командами
```
git add .
git commit -m "создал файлик"
```
`add` добавляет в сохранение указанные файлы в данном случае все которые находяться в деректории где выполняеться команда
`commit` это как кнопка `сохранить` `-m "создал файлик"` это имя сохраниения.

Для того что бы быстро глянуть на изменения существует команда `git show` что бы двигаться по git show нужно использовать стрелочки, а что бы выйти из git show нужно нажать `Q`.

Если мы изменим какой нибуть файлик Git это сразу заметит `git status` и нам покажеться информация о том что что то изменилось.

снова сохранимся
```
git add .
git commit -m "что то изменил"
```

теперь глянем как на историю коммитов `git log`
![[Pasted image 20240825204718.png]]
# жизненный цикл файлов в репозитории
В гит репозитории файлы могут находиться в нескольких состояниях
- закоммичен (сохранён)
- изменён добавлен в index гита то есть подготовлен к коммиту
- удалённый
добавить в индекс файл можно командой `git add path`. `git status` говорит нам в каком состоянии файл.

# игнор файлов
Для того что бы игнорировать файлы которые не должны войти в итоговый репозиторий а это прежде всего
- логи
- файлы которые не влияют на работу проэкта
- файлы с паролями
- бызы данных
- виртуальные окружения
- конфиг редактора кода
- пользовательские файлы
нужно использовать .gitignore
создадим файл .gitignore
```.gitignore
*.log  
logs/  
*.db  
database/
```
и папку `logs[err.log, info.logs]` а так же `database[database.db]`
теперь `git status`
![[Pasted image 20240825211957.png]]
 тут найден git ignore но файлы и папки которые создали не видно и в репозиторий они не попадут.

Если понадобиться исключить все файлы кроме опеределённого то мы используем игнорирование паттернов:

```
!logs/err.log
```
тут мы !отрицаем что мы игнорируем файл. При этом нельзя если использовать отрицание игнорить папку в которой есть файл который нужен.
# создание SSH ключа
Secure Shell (SSH) - способ общения с уалённым сервером или репозиторием. Его разница от HTTPS в том что в HTTPS придёться вводить пароль каждый раз а в SSH не придётся. То есть настроил и погнал.
## алгоритм созлания SSH ключа
1. в терминале вводим `ssh-keygen -t ed25519 -C "skillbox"`. Аргумент -t говорит о том какой будет тип у ключа. Параметр -С комментарий к SSH-ключу типо имя.
2. нужно ответить на вопросы в терминале 
	1. `Enter file in which to save the key (/home/mihsa/.ssh/id_ed25519):` тут у нас спрашиваеться в какой директории будет находиться ключ. Если нажать Enter то она поставиться по умолчанию
	2. `Enter passphrase (empty for no passphrase):` это ключивая фраза ключа то есть как бы его пароль. Если нажать Enter то она не будет поставлена
	3. `Enter same passphrase again` попросит ввести тот же пароль ещё раз но изза того что ранее мы поставили Enter то и сейчас Enter
	если вывелась вот такая штука то ты всё сделал правильно
	```python
	Your identification has been saved in /home/mihsa/.ssh/id_ed25519
	Your public key has been saved in /home/mihsa/.ssh/id_ed25519.pub
	The key fingerprint is:
	SHA256:EWcQZI4wzXKS+zKorVH9/eSNHK023zG73iMQ6yOoYyA skilbox
	The key's randomart image is:
	+--[ED25519 256]--+
	|    o+ .*o o     |
	|   +o++ +        |
	|     =. o        |
	|   ..    . .     |
	|  ....  S    o   |
	| E..o...+        |
	|.o. .o. o +o  o  |
	|...    o.*oB o * |
	|..    ..o.Bo+.*.o|
	+----[SHA256]-----+
	```
3. теперь введя команду cat `~/.ssh/id_ed25519.pub` мы выведем этот ключ
4. заходим на github profile>settigs>SSH and GPG keys>mew ssh key> и в форму копируем `~/.ssh/id_ed25519.pub`
5. клонируем созданый мной репозиторий `git clone git@github.com:medin-misha/learn_git.git` если будет вопрс на него отвечаем yes
готово ты скопировал репозиторий

## как явно указать какой SSH ключ нужно использовать для конкретной странички
В папке `~/.ssh/` создай файл config 
```shell
touch ~/.ssh/config
```
и напиши в этом файле следуйщее
```python
Host github-medin-misha
        HostName github.com
        User git
        IdentityFile ~/.ssh/id_ed25519                                         
```
# подключение к удалённому репозиторию
## через git clone 
Тут всё черезвычайно просто 
```shell
git clone <link-to-repo>
```
и заходишь в папку с названием репозитория
```shell
cd <repo-name>
```
вся теперь у тебя на компьютере есть рабочая копия проэкта
## создание нового репоизитория и подключение к ниму
обрати внимание на то что имена git репозиториев принято писать маленькими буквами а слова разделяются дефисом.
теперь в терминале 
```shell
git init 
# создадай какой нибуть файл и
git add .
git commit -m 'add new file'
# это подключение репозитория
git remote add origin git@github.com:medin-misha/git-learn.git
git push -u origin master
```
# ветки
Ветка это код приложения в разных версиях только сложнее:

> в основной ветке лежит само приложение со всеми фичами

и у нас есть 2 или больше программистов которым поручено выполнить 2 задания с добавлением фич, и что бы 2 программиста работали в одно время нужно 

> вторая ветка с которой работает перывый программист

> третья ветка с которой работает второй программист

после выполнения задач у нас имееться
- основная версия приложения (1 ветка)
- версия первого программиста (2 ветка)
- версия второго программиста (3 ветка)
для того что бы узнать в какой ветке мы работаем нужно написать
`git status` и там будет написана текущая ветка.
 
для создания новой ветки нужно
` git checkout -b super-vetka` эта команда создаёт и переключается на указаную ветку есть ещё `git branch super-vetka` она уже просто создаёт новую ветку не переключаясь 

для переключения между ветками нужно
`git checkout master` master - это название ветки

для того что бы посмотреть все ветки нужно использовать 
`git branch -a`

> Если для перехода на следуйщую ветку обязательно нужно коммитить изменения иначе будет ошибка

для отправки в репозиторий нужно делать команду
`git push --set-upstream origin oschen-interesnaa-vetka`

но что если создал в репозитории новую ветку не ты а её нужно скопировать? Для этого подходит `git pull` и у тебя есть все ветки и они актуальны

## слияние веток
Для слияния веток нужно написать команду `git megrge <name>` если мы будем работать из master то та ветка котораая указана в git merge будет влита в master.

Теперь про ручное слияние. Оно может понадобиться когда git не вдупляет что менять из-за сложных изменений или перечащих друг другу. После того как нас оповестил о конфликте в файле который конфликтует будет примерно такая конструкция
```
<<<<<<< HEAD
1,2,3,,123,,1,2,3,,12,3,1rq,e
=======
45,,6,6,23,4
>>>>>>> new-contacs
```
под тегом HEAD и до ===== это изменение в текущей ветке, а с ===== до >>>>> это пришедшие изменения. Мы можем вручную выбрать нужный вариант.
после разрешения конфликта пишем `git add .` `git commit -m "текст"`. Всё.

## откладывание изменения
Допустим мне в срочном порядке нужно переключиться на слудуйщую ветку и закомитить изменения я не могу.
`git stash` теперь можно переключиться и поработать с другой веткой. 
После работы над веткой возвращаемся на исходную и пишем `git pop` всё теперь продолжаем работать

для просмотра изменений `git stach` нужно ввести `git stach list`
## запрос на слияние
Это запрос на слияние ветки а которой выполнены те или иные изменения. С помощью такого запроса разрабы как бы говорят "задача выполнена проверь мой код". После глав разраб проверяет всё и позволяет или отклоняет.
## просмотр изменений
Для того что бы видеть изменения файлов есть для этого команда `git diff`. Команда показывает изменения в файлах, так же в неё можно передать путь к файлу и посмотреть изменения конкретного файла.
### просмотр изменений между коммитами
Для просмотра изменений между коммитами нужно узнать id нужного коммита (за список коммитов отвечает `git log`) и передать 2 коммита  в команду `git diff` выглядит это как-то так:
```
git diff ced3997f913622593e90066546fc6d2c89222ed4 d382066f467ff2240156595a83a0819d444cf681
```
вот эти непонятные символы это id коммитов. К стати эту хуету можно не писать в место полного id можно написать только первые 4 символа:
```
git diff as12 a1ddf
```
## удаление незакоммиченых изменений
Допустим что ты совершил ошибку и накосячил где то в коде, но ты пока незакоммитил изменения. Так вот, для того что бы откатить файл к последнему коммиту нужно написать `git restore filename` и файл откатиться.

Рассмотрим случай намного хуже. Ты всё таки написал `git add file` и добавил в индекс. Для исправления этой ошибки есть команда  `git restore --staged filename` и вызволит твой файл из коммита 

А для того что бы удалить все незакоммичиные изменения кроме файлов о которых git незнает нужно использовать `git reset --hard`

Для того что бы удалить ВООБЩЕ все незакомичиные изменения нужна команда `git clean -f` пользоваться нужно окуратно по тому что нельзя вернуть ничего назад после выполнения команды.

## удаление закоммиченых изменений
### откат файла к комиту
Для того что бы откатить файл к определённому коммиту нужно узнать id коммита (git log) и ввести команду `git checkout 168d index.html` 168d - первые 4 знака из id коммита
## отмена коммитов
Для отмены конкретного коммита нужно использовать команду `git revert id` на месте id первые 4 знака id коммита
## git reset
указатель head - в номе это указатель на последний коммит в последней версии с которой ты работаешь. Если ты укажешь git reset --soft id то указатель head будет указывать на прошлый твой шаг. При этом изменения в файле сохоняться только не будут закоммичены. Если мы исполним команду git reset --mixed id то изменения всё так же сохраняться только недобавлены в индекс.
## Удаление файлов из отслеживания
Для начала добаляем желаемый файл в .gitignore и `git rm --cached filename` всё. Файл удалён из отслеживания

# отмена слияний веток
Для отмены слияния существует команда `git reset --merge id` id коммита до слияния. Если слияния не произошло изза конфликта то `git merge --abort`

переменование ветки, сначала нужно в неё переключиться и за тем git branch -m newname.

Удаление ветки теперь не находясь в ветке которую мы хотим удалить и `git branch -D newname`

## общепринятые правила работы с git
### именования веток
Ветки должны быть названы таким образом что бы было АБСОЛЮТНО очевидно работа над чем ведётся работа в ветке. Вот очень простые 3 правила следуя которым всё будет + - окуратно 
1. Название содержит только Цифры, латинские буквы в нижнем регистре, дефисы в вместо пробелов
2. Номер задачи в место первого слова если есть
3. описание задачи разделённая дифисами
Вторые варианты:
- master \ main
- dev \ develop \ devel
- test \ staging
- production
- fixes \ hot-fixes
### то что должно попадать в commit
То какие коммиты будут у тебя в репозе зависит то насколько круто и удобно будет работать с твоим репозиторием.

в коммит должны попадать либо реализованная задача, либо результат работы за N-ный временной периуд как правило за 1 день.

В коммите ненужно отправлять каждую строку. В коммите должен быть осмысленный набор изменений.
### комментарии коммита
В комментарии к коммиту нужно писать либо подробный комментарий того что ты сделал в этом коммите либо краткая пара слов которая будет понятна твоим коллегам то есть суть изменений.

Так же есть формат "Conventional Commits" по сути это свой HTML только в git commit