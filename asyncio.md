## термины
**event loop** - это среда выполнения корутин в одном потоке.Циклы событий запускают асинхронные задачи и обратные вызовы, выполняют сетевые операции ввода-вывода и запускают подпроцессы. Вот то чем чаще всего занимаються корутины
- Выполнение корутин.
- Выполнение коллбэков.    
- Выполнение сетевых операций ввода/вывода.
- Выполнение подпроцессов.

**Корутин** - это функция которая которая может остановиться в определённой точке и за тем начать выполняться с той же точки не блокируя (останавливая) основной поток выполнения.

**Асинхронный вызов функции** это способ вызова функции в фоне во время которого программа может выполнять дополнительно какие то задачи. 

**Объект future**: идентификатор асинхронного вызова функции, позволяющий проверять состояние вызова и получать результаты работы функции.

**Асинхронная задача**: этот термин используется для обозначения сущности, представляющей собой объединение асинхронного вызова функции и порождённого этим вызовом объекта `Future`.

**Неблокирующий input\output** - это когда программа запрашивает у системы чтение или запись неких данных и во время этой операзии имеет возможность заниматься чем нибуть ещё. Программа не зависает в ожидании чтения или записи данных.

**асинхронное програмирование в [[python]]** -  это выполнение запросов без блокировки(остановки) основной программы.

**функция корутины** - это функция которая возвращает обьект корутины. Может содержать корструкции await, async for, async with. В перечисленых местах корутина может быть остановлена.

**кооперативная многозадачность** — это тип многозадачности, при котором фоновые задачи выполняются только во время простоя основного процесса и только в том случае, если на это получено разрешение основного процесса

Смысл асинхронного программирования заключается в том что бы длительные задачи запускать в **фоне** как бы отдельно он основного приложения, в место того что бы останавливать главное приложение при каждой длительной задачи на время выполнения этой задачи. После завершения этой задачи мы как бы получаем уведомление "я завершил своё выполнение." и обрабатываем результат.

## практика
### работа с корутинами
Корутина определяется как обычная функция только с async. (`async def`) Такая конструкция называется **функция корутины**.

```python
#определение корутины
async def custom_corotine():
	await asyncio.sleep(1)
#создание корутины
corotine = custom_corotine()
```
в ходе `corotine = custom_corotine()` корутина не выполняеться по тому что `custom_corotine()` возвращает **обьект корутины**(types.coroutine). У обьекта корутины есть функции [[генераторы python|send и close как в генераторах]] 

Корутины выполняются в event loop (цикле событий), но создавать их можно и в обычном python коде. Корутины работают в цикле событий по принципу кооперативной многозадачности. Сам обьект корутины может быть выполнен лишь в том случае когда работает event loop.

что бы запустить корутину нужно использовать `asyncio.run()`. Эта функция запускает новый event loop а аргументом к этой функции должна быть выполняемая корутина. Чаще всего эта корутина main которая вызывает все остальные корутины. А ещё функция `asyncio.run()` в идеале должна вызываться только один раз.

вот как запуск event loop и корутин выглядит.
```python
import asyncio

# определение корутины
async def custom_coro():
	await asyncio.sleep(1)
print("корутина custom_coro() выполнелась")
  
async def main():
	print("корутина custom_coro выполняеться")
	await custom_coro()
  
#запуск основной корутины
asyncio.run(main())
```

К стати вне event loop и в event loop мы можем обращаться к циклу событий. Функцией `get_running_loop`

Итак мы научились создавать и запускать корутины. Тепарь научимся их запукать в асинхронном режиме.

Обьекты `Task` можно создавать из корутин. Задачи представляют для сильного и независимого планирования и выполнения корутин. `asyncio.Task` - это обьект который отвечает за планирование выполнения asyncio-корутин а так же за их независимый запуск.

>Задача — это объект, который отвечает за управление корутинами и за их независимый запуск.

Задачи создают из корутин. Они оборачивают корутины и дают интерфейс для запуска, планирования, и получения информации корутины. Такой подход избавляет нас от роскоши ничего не делая ждать пока корутины будут выполняться.

Как создать задачу?
Задачу можно создать, прибегнув к функции [asyncio.create_task()](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task). Эта функция создаёт класс asyncio.Task и принимая в себя обьект корутины.

```python
coro = custom_coro()
task = asyncio.create_task(coro=coro)
```

- корутина оборачиваеться в екземпляр task
- планируеться выполнение задачи в event loop
- возвращаеться екземпляр task

запустить задачу можно вот так
```python
await task
```

более наглядный пример
```python
import asyncio
  
# определение корутины
async def custom_coro():
	await asyncio.sleep(30)
	print("корутина custom_coro() выполнелась")
	async def custom_coro2():
	print(asyncio.get_running_loop())
  
async def main():
	#создание корутин
	coro = custom_coro()
	coro2 = custom_coro2()
	#создание задач
	task1 = asyncio.create_task(coro=coro)
	task2 = asyncio.create_task(coro=coro2)
	# ожидание выполнения задач
	await task1
	await task2

#запуск основной корутины
asyncio.run(main())
```

вывод будет вот такой:
```shell
<_UnixSelectorEventLoop running=True closed=False debug=False>
корутина custom_coro() выполнелась
```
хоть мы и запустили task1 первым, мы не ждали 30 секунд пока он выполниться. Во время сна (`await asyncio.sleep`) выполнилась task2

задачи это вообще основная волюта asyncio программ. Жизненный цикл задачи выглядит примерно вот так:
1. Создана (Created).
2. Запланирована (Scheduled).    
3. Выполняется (Running).
4. Завершена (Done).
между этими пунктами есть и дополнительные елементы такие как, отменена, выдала исключение, приостановлена, вернула результат
![[Pasted image 20240730163522.png]]
после создания задачи можно проверить в каком она состоянии.

```python
state_string: str = f"""
task.done() - {task1.done()}
task.result() - {task1.result()}
task.exeption() - {task1.exception()}
task.cencelled() - {task1.cancelled()}
"""
```
вот примерно какой результат будет у этой строке
```
task.done() - True
task.result() - None
task.exeption() - None
task.cencelled() - False
```
- задача завершаеться (done == True) в случае завршения работы корутины, возвращение явного результата, отмены и ошибки.
- задача отменена в случае вызова метода cancel() у задачи
- задача возвращает результат явно обёрнутым обьектом Task или не возвращает None или ошибки
- получить исключение которое выдала корутина можно через метод exeption

задачу так же можно оснастить callback-ом (функцией которая выполняеться по завершению задачи)
```python
task2 = asyncio.create_task(coro=coro2)
task2.add_done_callback(callback_func)
```
стоит учитывать что в callback функцию передаёться и сама задача. То есть нужно сделать callback функцию которая принимает задачу иначе будет исключение. Так же callback-и можно удалять и добовлять сколько угодно.
добавление callbacke-ов
```python
# добавление
task2.add_done_callback(callback_func)
task2.add_done_callback(callback_func1)
task2.add_done_callback(callback_func2)
task2.add_done_callback(callback_func3)
# удаление
task2.remove_done_callback(callback_func)
task2.remove_done_callback(callback_func1)
task2.remove_done_callback(callback_func2)
task2.remove_done_callback(callback_func3)
```

задаче ещё можно назначить имя и получать имя
```python
task1 = asyncio.create_task(coro=coro, name="coro")
# или через set_name
task1.set_name("coro")
# получение имени
print(task1.get_name())
```
это можно использовать как то так
```python
def callback_func(task):
    print(f"задача custom {task.get_name()} выполнелась ")

task2 = asyncio.create_task(coro=coro2, name="coro2")
    
task2.add_done_callback(callback_func)
```

для получения текущей выполняемой задачи нужно использовать метода current_task()

```python
# пример получения текущей задачи из главной корутины
import asyncio
# определение главной корутин
async def main():
	# вывод сообщения
	print('main coroutine started')
	# получение текущей задачи
	task = asyncio.current_task()
	# вывод сведений о ней
	print(task)
# запуск asyncio-программы
asyncio.run(main())
```
это может понадобиться для логирования

получить все задачи можно 
```python
tasks = asyncio.all_tasks()
```
может понадобиться для логирования или грамотного завершения. Вывод этой функции это множество, то есть каждая задача будет представлена в едином екземпляре.


Asyncio позволяет запускать несколько корутин в конкурентном режиме. Корутины могут быть созданы в виде группы и сохранены. А потом их можно все сразу запустить в конкурентном режиме. Реализуеться такое с помощью `asyncio.gather()`. Так же эта функция даёт больше фичей чем простое ожидание задач.

В asyncio.gather можно пожать множество **задач**  множество **корутин** множество **корутин и задач**.

```python
import asyncio

async def coro1():
	await asyncio.sleep(1)
	print("я выполняюсь coro111")

  
async def coro2():
	await asyncio.sleep(0.9)
	print("я выполняюсь coro222")
  
async def main():
#выполнение группы обьектов
	await asyncio.gather(coro1(), coro2())
	  
asyncio.run(main())
```
gather не может принимать один аргумен типа list в него нужно напрямую кидать задачи и корутины или если всётаки списком то перед списком ставить `*` то есть распаковатть.
```python
asyncio.gather(*[coro1(), coro2()])
```
gather к стати не являеться блокирующей.

для лучшего понимания этого механизма и в целом асинхронности можно рассмотреть вот такой вот код:
```python
import asyncio
import random
  
async def coro(number: int):
	rand_time: int = random.randint(1,5)
	await asyncio.sleep(rand_time)
	print(f"номер выполнения: {number}, время выполнения: {rand_time} сек")
  
async def main():
	await asyncio.gather(
	*[coro(i) for i in range(10)]
	)
  
asyncio.run(main())
#вывод будет примерно таким:
|> номер выполнения: 8, время выполнения: 1 сек
|> номер выполнения: 2, время выполнения: 2 сек
|> номер выполнения: 3, время выполнения: 2 сек
|> номер выполнения: 9, время выполнения: 2 сек
|> номер выполнения: 1, время выполнения: 3 сек
|> номер выполнения: 7, время выполнения: 3 сек
|> номер выполнения: 4, время выполнения: 4 сек
|> номер выполнения: 6, время выполнения: 4 сек
|> номер выполнения: 0, время выполнения: 5 сек
|> номер выполнения: 5, время выполнения: 5 сек
```
В строке `*[coro(i) for i in range(10)]` я создал и распаковал 10 экземпляров корутины `coro`. И запустил их одновременно. Поскольку каждая корутина засыпает на интервал от 1 до 5 секунд, в этот интервал программа вызывает другие корутины, которые также засыпают на случайное время от 1 до 5 секунд. Далее программа продолжает выполнение и проверяет, какая корутина проснется раньше, и выполняет её.

Программа не будет выполняться больше 5 секунд, так как наибольший возможный интервал для засыпания корутины составляет 5 секунд. Поскольку все корутины запускаются почти одновременно, они завершаются в пределах этого временного интервала, хотя и не обязательно в один и тот же момент.

функция `asyncio.wait()` очень интересная и полезная функция которая позволяет ставить условие для выполнение корутин. Это та же gather только в неё можно передавать условия аргументом **return_when**

- `asyncio.ALL_COMPLETED`: Ожидать завершения всех переданных задач.
- `asyncio.FIRST_COMPLETED`: Ожидать завершения первой задачи.
- `asyncio.FIRST_EXCEPTION`: Ожидать завершения первой задачи с исключением (или завершения всех задач).


