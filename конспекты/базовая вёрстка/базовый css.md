Самый простой способ подключить стили к html это в теге head прописать тег `<style>` который будет отвечать за стили. Но в индустрии принято держать (каскадные таблицы стилей) css в отдельных файлах. 

Но как подключить каскадные таблицы стилей? Всё очень просто.
В теге `<head>` вставляем тег `<link>` вот так это выглядит:
```html
<head>
    <link rel="stylesheet" href="style.css">
    <title>Document</title>
</head>
```
по пути href создай файл style.css и всё.

## css селекторы
Селектор - это то что позволяет нам выбрать какой то тег или группу тегов.
#### *
Селектор обозначающий все теги. Спорно но если акуратно то использовать сложно
```css
* {
    color: red;
}
```
весь текст на странице будет иметь красный цвет
#### ИМЯ ТЕГА
Если вписать тег допустим h1 то мы выберем все обьекты тега h1 вот как то так это и выглядит:
```css
h1 {
    color: red;
}
```
тут выбраны все теги h1 и они будут покарашены в красный. Метод спорный по тому что изменения могут быть черезчур глобальными. Так же можно перечислять селекторы через запятую и они могут быть раными:
```
h1, p {
    color: red;
}
```
#### .class
Это самый трушный способ стилизации. В теге нужно в качестве атрибута указать `class="name"` и потом через `.` обратиться к классу в css.
```html
<p class="text">Lorem ipsum dolor sit amet consectetur adipisicing elit. Error laboriosam architecto, tempore ad omnis ducimus et assumenda quo, quos fuga odio eligendi nam reiciendis corporis quam maxime enim dicta provident.</p>

<p class="text">Lorem ipsum, dolor sit amet consectetur adipisicing elit. Consectetur distinctio nam aliquam dicta omnis ad ex ea voluptatibus incidunt, laudantium ab ipsum autem fugiat aspernatur recusandae quo illo rerum nostrum.</p>
```
```css
.text {
    color: yellow;
}
```
Все елементы с классом text будут иметь цвет текста желтый.
#### .id
В теге нужно в качестве атрибута указать `id="name"` и потом через `#` обратиться к id в css. Id имеет больший вес чем .class но всё же стараемся его не использовать что бы не запутаться. Так же id должен быть только 1 на всю страницу. То есть 2 тега с идентичными id недолжно быть.

Вот как это может выглядить
```html
<p class="text" id="asd">Lorem ipsum, dolor sit amet consectetur adipisicing elit. Consectetur distinctio nam aliquam dicta omnis ad ex ea voluptatibus incidunt, laudantium ab ipsum autem fugiat aspernatur recusandae quo illo rerum nostrum.</p>
```
```css
.text {
    color: yellow;
}
#asd {
    color:aquamarine;
}
```
Текст будет аквамаринового цвета.
## вес селектора
- Id имеет больший вес чем class в любом случае
- стилизация по class имеет больший вес чем стилизация по тегу
- атрибут style имеет больший вес чем селектор по тегу
- последнее правило в правилах с одинаковым весом имеет большее значение. То есть если есть много .class меняющие одно и тоже свойство то последнее правило будет применено
- если написать в стиле `important` то мы обозначим его самым важным и самым тяжелым. `color: yellow !important;`
## Единицы измерения
**px**- обсолютная единица измерения. В не зависимости от размера экрана размер будет фиксированный 100px всегда будет 100px. Но пиксели не имеют совершенно никакой адаптивностью.
% - проценты зависят от размера тега body. Если процент вложен куда то допустим в div то это будет % от ширины родителя.
em - зависит от размера шрифта у родителя.
rem - зависит от размера шрифта для тега html
## блочная модель 
Блочная модель описывает то как себя ведёт елемент на страницы и те свойства которые влияет его размер. А влияют;
- margin
- border
- padding
- width & height
вот так. Если значение не задано то оно равняеться 0.
Блок почти всегда имеет большие размеры чем указанны в width & height. Как бы это очевидно не было но на размер влияют border + padding размер которых складываеться. Это учитывать. Но это поведение можно изменить свойством box-sizing.
## отступы по умолчанию
У html есть стандартные стили которые помогают html не быть комом слепленного чёрно-белого говна. Что бы убрать эти отступы что бы полностью контролировать все стили (или сделать html чёрно-белым комом говна) нужно сделать вот так:
```css
* {
	margin: 0;
	padding: 0; 
}
```
файл reset.css.
Это файл который НАХУЙ убирает все бесполезные свойства, [[reset.css]].
Но что если тебе не нужно обнулять всё и вся? Есть файл [[normalize.css]] который делает всё +- норм.
## css свойства
### свойство display
Существуют 2 типа елементов. Строчные и Блочные. Именно это свойство меняет **display**. У него есть несколько свойств:
- `none` просто убирает блок. Его невидно и неслышно и он ни на что не влияет
- `block` занимает всё доступное себе пространство
- `inline` занимает минамально требуемое пространство. Игнорируют width и height а так же margin и padding в нём так же не могут находиться блочные елементы.
- `inline-block` не занимает полностью всё пространство родителя но и не имеет ограничений inline.
### margin
Margin - это внешние отступы. Есть длинная и короткая форма записи.
```css
.div {
	margin: 1px 2px 3px 4px;
}
```
1 пиксель сверху, 2 пикселя с права, 3 пикселя с низу и 4 пикселя слева.
```css
.div {
	margin: 0px 2px;
}
```
первое значение (0px) отвечает за вертикальные значения (верх и низ), второе значение (2px) отвечает за горизонтальные значения (право и лево).
```css
.div {
	margin: 2px;
}
```
со всех сторон отступ 2 пикселя.
```css
.div {
	margin: 2px 10px 3px;
}
```
с верху 2px с права и лева 10px c низу 3px.
Так же можно использовать точечную запист
```css
.div {
	margin-top: 2px;
	margin-right: 2px;
	margin-bottom: 2px;
	margin-left: 2px;
}
```
У блочных елементов margin не как не складывается. То есть если у нас есть 2 блока у который margin 10px и 15px будет расстояние меж блоками будет 15px
### padding
Padding - это отступы внутри самого елемента. Тут механика записи такая же как и у margin.
### border
border-width - толщина обводки
border-style - стиль обводки
border-color - цвет обводки
всё это можно задать в свойстве border. К стати border так же увеличивает размер блока это стоит учитывать.
### width height
Ширина и высота, не работает на строчных елементах. Можно к стати задавать Минимальные и максимальные величины.
```css
div {
    background-color: blueviolet;
    min-width: 50px;
    min-height: 50px;
    max-width: 500px;
    max-height: 500px;
    border: 4px dotted red
}
```
В минимальных размерах блок будет 50 на 50 пикселей, а в максимальных 500 на 500 пикселей.
### box-sizing
Свойство меняющее блочную модель елемента. Люди часто используют значение border-box.
```css
div {
    background-color: blueviolet;
    padding: 10px;
    border: 4px dotted red;
    box-sizing: content-box;
}
```
Если вставить значение `content-box` то padding будет влиять на размер блока. А если вставить border-box то padding не будет влиять на размеры
### float
Свойство `float` устарело но знать о нём стоит. Это свойство заствляет елемент прижиматься к left или right а остальные елементы как бы елемент с этим свойством:
![[image_019.png]] вот так оно выглядит.
#### owerflow-x-y
Свойство owerflow очень класное свойство которое позволяет скролить елемент. Для него есть несколько значений:
- auto - если текст слижком большой для блока то он начинает скролится 
- hidden - то что не поместилось обрезаеться
- visible - то что не поместилось - то не поместилось
- scroll - scroll-bar отображается всегда, даже если скроллить нечего
так же можно указывать owerflow-свойство в формах:
- owerflow: auto; настройка одновременно X и Y
- owerflow-x: auto; настройка только по оси Y
- owerflow-y: auto; настройка по оси Y
#### z-index
Свойство позволяющее превращать вёрстку в слоистый пирог. Тот елемент у которого z-index выше в числовом формате тот и будет выше, что логично. Так же если нужно унизить элемент z-index можно поставить отрицательный. 
#### color
Свойство которое позволяет менять цвет текст
#### opacity
Отвечает за альфа-канал (прозрачность) елемента:
`opacity:0.5;` делает элемент полу-прозрачным или прозрачным
#### text-decoration
Свойство отвечающее за декорацию текста. Именно оно отвечает за линии:
- underline - подчёркивание
- none - отсуцтвие декорации
- line-through - перечёркнутый текст
- overline - линия сверху
- initial - изначальный
- inherit - как у родителей
#### text-align
Настройка расположения текста вот его значения:
- center - центр
- left\right - право лево
- justify - текст старается заполнить собой всё пространство
#### text-transform
Свойство для трансформации текста:
- none - Не оБрабОтанЫй тЕкст
- capitalize - Каждое Слово Написано С Большой Буквы
- uppercase - КАЖДАЯ БУКВА ПИШЕТСЯ С БОЛЬШОЙ БУКВЫ
- lowercase - все буквы кроме первой будут маленькими
#### line-height
свойство которое отвечает за отступ по вертикали между текстом
#### letter-spacing
Свойство расстояния между символами в тексте
#### white-space
Свойство отвечает за переносы:
- nowrap - не переносит
- pre - то как текст находиться в коде (осторожнА)
#### border
Это свойство границы (обводки) обьекта. Вот как им пользоваться:
```css
border: 5px dashed red;
```
Первым аргументом идёт толщина обводки, она может быть в любых еденицах измерения, дальше идёт тип, чаще всего это sofid(сплошная линия), но можно поставить dotted(точечная линия типа .......)  или dashed(------), double(двойная линия), после типа идёт цвет.
#### border-radius
Свойство которое позволяет мне скруглять углы блока\обьекта. 
```css
border-radius: 10px 0 10px;
border-radius: 10px 0 10px 10px;
border-radius: 10px 0;
border-radius: 10px ;
```
принимает много форм записи скругляет углы блока.
#### outline
Это тоже самое что и border только он делает **больше только визуально** а border делает блок **больше в блочной модели**
```css
oultine: 5px dashed red;
```
Первым аргументом идёт толщина обводки, она может быть в любых еденицах измерения, дальше идёт тип, чаще всего это sofid(сплошная линия), но можно поставить dotted(точечная линия типа .......)  или dashed(------), double(двойная линия), после типа идёт цвет.
#### box-shadow
Очень ресурсозатратное свойство которое задаёт тени для элемента принимает много аргументов.
аргументы:
1. inset(необязательно) если не указано то тень будет откидывается от елемента. Если оргумент указан то создаёт еффект впуклости блока
2. offset-x\y значение offset-x задаёт тень по горизонтали а offset-y по вертекали, оба значения обязательны для работы
3. spred-radius(необязательно) размытие, чем больше значение к 0 тем более чётка тень. Может принимать px em
4. color - цвет тени
```css
box-shadow: inset 1em 1em 2em gold;
```
#### text-shadow
Свойство text-shadow отвечает за тени от текста вот его аргументы:
- color - цвет тени
- offset-x\y значение offset-x задаёт тень по горизонтали а offset-y по вертекали, оба значения обязательны для работы
- blur-radius - радиус размытия тени
#### background-color
цвет заливки заднего фона елемента.
#### background-image
получает ссылку на изображение в виде url(https://asda) и ставит картинку на задний фон
#### background-position
Это свойство будет управлять где в пространстве будет лежать задний фон по оси x y
можно:
- center center - картинка в центре
- left left - картинка с лева 
- right right - картинка с права
и комбинированные
#### background-repeat
Если картинка меньше блока то по умолчанию она будет повторяться. Так что это свойство помогает контролировать повторение заднего фон:
- repeat - повторяеться
- repeat-x\y - повторяется по одной из осей
- no-repeat - не повторяеться
#### background-size
размер картинки заднего фона

#### visibilyty
Отвечает за видимость елемента, можно сделать елемент невидимым таким образом что бы он отображася в потоке но взаемодействовать с ним было нельзя `visibility: hidden` по умолчанию оно visible
#### list-style
Допустим у нас есть список чего либо
```html
 <ul>
        <li>123</li>
        <li>123</li>
        <li>123</li>
        <li>123</li>
        <li>123</li>
</ul>
```
и вместо нужно заменить точки на что то другое
```css
ul{
    list-style: none/square/inside/url(image/);
}
```
#### cursor
При наведении на элемент ты можешь управлять тем, как выглядит курсор пользователя:
```css
button {
	cursor: pointer;
	cursor: grab;
	cursor: zoom-in;
	cursor: not-allowed;
	cursor: crosshair;
	...
	cursor: auto;
}
```