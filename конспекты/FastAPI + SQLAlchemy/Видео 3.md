# olembic
мы научились работать в [[Видео 2]] c базой данных, создавать модели и CRUD операции совершать. Допустим ситуацию когда нужно обновить проект и подумать как обновить уже созданную модель. В этом поможет olembic. 
напомню что
```python
await conn.run_sync(Base.metadata.create_all)
```
только создаёт таблицы но через create_all нельзя создавать таблицы.

установим alembic
```shell
poetry add alembic
```
и в папке проекта его нужно про инициализировать в асинхронном формате
```shell
alembic init -t async init
```
после выполнения создасца папка alembic и alembic.ini в папке alembic есть:
- директория versions
- env.py
- README.md
- script.py.mako (шаблон кода на питоне)
в файле alembic.ini содержится конфигурации для миграций. Для более понятной визуализации файлов миграций нужно разкоментировать или написать вот эту строчку в файл
```ini
[alembic]
file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s
```

теперь если мы в терминал напишем 
```shell
alembic revision -m "create account table"
```
то в alembic/versions создасца новый файл типо такого `2024_09_14_1638-855e78fafd96_create_account_table.py`
в файле `2024_09_14_1638-855e78fafd96_create_account_table.py`
```python

from typing import Sequence, Union  
  
from alembic import op  
import sqlalchemy as sa  
  
  
# revision identifiers, used by Alembic.  
revision: str = '855e78fafd96'  
down_revision: Union[str, None] = None  
branch_labels: Union[str, Sequence[str], None] = None  
depends_on: Union[str, Sequence[str], None] = None  
  
  
def upgrade() -> None:  
    pass  
  
  
def downgrade() -> None:  
    pass
```
будет примерно такой код.
- revision это уникальный id миграции
- down_revision указывает на предыдущую миграцию. Если None то это первая миграция.
- branch_labels ветвления миграций
- depends_on зависимости от миграций.

функции upgrade и downgrage отвечают за обновления миграций и возвращении к предыдущей миграции соотвецтвенно.

По скольку я не хочу описывать методы update и downgrade то в alembic/env.py я опишу автогенерацию моделей.
```python
# было ----
# from myapp import mymodel  
# target_metadata = mymodel.Base.metadata  
target_metadata = None

# стало ----
from core.models import Base  
target_metadata = Base.metadata
```
далее нам нужно указать ссылку на базу данных. По скольку мы знаем что ссылка находиться в core.settings мы не будем указывать её в alembic.ini по тому что мы так повторим код что будет не приятно а будем указывать в alembic/env.py. Добавим в env.py вот эти 2 строчки чуть ниже нашего прошлого изменения в alembic/env.py
```python
from core.config import settings  
config.set_main_option("sqlalchemy.url", settings.db_url)
```
добавим новое поле в Product
```python
  
class Product(Base):  
    name: Mapped[str] = mapped_column(String(20))  
    description: Mapped[str]  
    description2: Mapped[str] | None
    price: Mapped[int] = mapped_column()
```
теперь в терминале пропишем
```shell
alembic revision --autogenerate -m "create table"
```
создасца миграция 
```python
def upgrade() -> None:  
    # ### commands auto generated by Alembic - please adjust! ###  
    op.add_column('products', sa.Column('description2', sa.String(), nullable=True))  
    # ### end Alembic commands ###  
  
  
def downgrade() -> None:  
    # ### commands auto generated by Alembic - please adjust! ###  
    op.drop_column('products', 'description2')  
    # ### end Alembic commands ###
```
и что бы мигрировать пропишем
```shell
alembic upgrade head
```
всё.
После создания и мигрирования мы откатим изменения назад командой
```
alembic downgrade -1
```

Теперь удалим базу данных, и удалим новое поле в Product и саму миграцию. Они нам больше не нужны.

!!! важно что все миграции alembic хранит в базе данных и если ты хочешь удалить миграцию нужно сначала удалить её из бд а потом файл миграции, или удалить базу данных и миграцию, или откатиться до предыдущей миграции и удалить ту с которой ты откатился.

Теперь когда мы научились мигрировать базу данных надобность создания бд при запуске приложения отпала и модно удалить метод lifespan из main.py файла

теперь в core/models/user.py создадим модель User
```python
from .base import Base  
from sqlalchemy.orm import Mapped, mapped_column  
from sqlalchemy import String  
  
class User(Base):  
    username: Mapped[str] = mapped_column(String(50), unique=True)
    posts: Mapped[list["Post"]] = relationship(  
    back_populates="user"  
)
```
не забудь добавить его в `__init__.py`. По скольку прошлую базу данных мы удалили то создадим новую и сразу мигрируем (всё для этого уже настроено)
```
alembic revision --autogenerate -m "database init"
alembic upgrade head
```
и создадим модель Post это то что может постить пользователь
```python
from .base import Base  
from sqlalchemy.orm import Mapped, mapped_column  
from sqlalchemy import String, Text  
  
class Post(Base):  
    title: Mapped[str] = mapped_column(String(50), unique=False)  
    text: Mapped[str] = mapped_column(Text, default="", server_default="")  
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), 
	    nullable=False
	)
	user: Mapped["User"] = relationship(  
    back_populates="posts",  
)
```
тут в text указано свойством default что нужно на стороне sqlalchemy создать дефолтное значение этого поля. А server_default означает что даже если мы залезем в саму бд и что то там создадим то значение по умолчанию тоже будет создано. Для больщих текстов (типо текста поста) нужно использовать не sqlalchemy.String а Sqlalchemy.Text так будет оптимизированна работа с текстом.


relationship-ы это не колонки модели а лишь абстракция которая позволит быстрее и легче работать с связными моделями. В нашем случае связь один(user)-ко-многим(posts). 

# models mixins
К стати тут тоже можно прям дико упростив добавив миксины
в core/models/mixins.py
```python
from sqlalchemy.orm import declared_attr, relationship, Mapped, mapped_column  
from sqlalchemy import ForeignKey  
  
class UserRelationMixin:  
    user_id_unique: bool = False  
    user_id_nullable: bool = False  
    user_back_populates: str | None = None  
  
  
    @declared_attr  
    def user(cls) -> Mapped["User"]:  
        return relationship("User", back_populates=cls.user_back_populates)  
  
    @declared_attr  
    def user_id(cls) -> Mapped[int]:  
        return mapped_column(ForeignKey("users.id"), unique=cls.user_id_unique, nullable=cls.user_id_nullable)
```
Пройдёмся по свойствам класса
- user_id_unique являеться ли связь уникальной, то есть это нужно для того что бы указать что связь являеться 1-to-1 При True
- user_id_nullable может ли user_id отсуцтвовать. True - да False - нет
- user_back_populates свойство которое указывает на то как называеться связная модель у Users нужна для relationship не обязательна
@declared_attr - это очень удобный метод который создаёт ДИНАМИЧЕСКИ ОПРЕДЕЛЁННЫЙ АТРИБУТ (ПЕРЕМЕННУЮ)
- user_id создаёт связь many-to_one или если user_id_unique True то 1-to-one
- user создаёт связь которая не отображается в базе данных никак но ORM как бы подтягивает под эту переменную User-а когда он нужен
core/models/post.py
```python
from .base import Base  
from sqlalchemy.orm import Mapped, mapped_column, relationship  
from sqlalchemy import String, Text, ForeignKey  
from .mixins import UserRelationMixin  
  
  
class Post(Base, UserRelationMixin):  
    user_id_unique = True  
    user_id_nullable = False  
    user_back_populates = "posts"  
  
    title: Mapped[str] = mapped_column(String(50), unique=False)  
    text: Mapped[str] = mapped_column(Text, default="", server_default="")
    )
```
Изза миксина и динамически определяемого атрибута в UserRelationMixin (@declared_attr) тут теперь нужно только определить настройки связи а не ебаться со связями
core/models/profile.py
```python
from .base import Base  
from .mixins import UserRelationMixin  
from sqlalchemy.orm import Mapped, mapped_column, relationship  
from sqlalchemy import ForeignKey, String  
  
class Profile(UserRelationMixin, Base):  
    user_back_populates = "profile"  
    user_id_nullable = False  
    user_id_unique = True  
  
    first_name: Mapped[str] = mapped_column(String(50), nullable=True)  
    last_name: Mapped[str] = mapped_column(String(50), nullable=True)
```
тут принцып такой же как и в /core/models/post.py