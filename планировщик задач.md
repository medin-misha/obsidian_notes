#### планирование задач
> планирование задач позволяет мне запланировать выполнение задач на опеределённое время или выполнять задачу через интервалы времени

попробуем сразу запланировать задачу на каждую минуту
```python
import random  
from celery import Celery  
from celery.schedules import crontab

app = Celery(  
   __name__,  
   broker='redis://localhost:6379/0',  
   backend='redis://localhost:6379/0'  
)

@app.on_after_configure.connect  
def setup_periodic_tasks(sender, **kwargs):  
    sender.add_periodic_task(30, cat())  
    
@app.task  
def cat():  
    if random.random() > 0.5:  
        print("кот что то сломал")  
    else:  
        print("кот играеться")
```
- функция `cat` это выполняемая функция.
- функция setup_periodic_tasks функция в которую мы указываем то что нам нужно сделать
разберём функцию setup_periodic_tasks по строчно
> `@app.on_after_configure.connect` - этот декоратор указывает на то что нужно запустить функцию когда Celery приложение будет настроено.
> `sender` аргумент sender это аргумент который всегда передаёться функциям под декоратором `@app.on_after_configure.connect` в данном случае sender это само `app`
> `sender.add_periodic_task` - это метод который подаёт задачу в планеровщик его аргументы (30, cat) это интервал в секундах и задача которую нужно выполнить.

что бы корректно передавать в функцию аргументы нужно использовать `.s()`
```python
@app.on_after_configure.connect  
def setup_periodic_tasks(sender, **kwargs):  
    sender.add_periodic_task(5, hello.s(arg=1)) 
@app.task  
def hello(name: str) -> None:  
    print(f"hello {name}")
```
тут я указал раз в 5 секунд выполнять функцию hello. К стати если не использовать `.s` то ничего не будет, функция просто не будет работать

запускать всё это дело прийдёться через команду
```shell
celery -A tasks beat
```
а потом уже 
```python
celery -A tasks worker
```
тут мы включаем планировщик

при обновлении таймера нужно перезапускать beat а не worker


##### более сложное описание времини
допустим мне не хочеться писать каждый раз интервал в секундах, это будет не удобно когда я оперирую днями или часами намного проще использовать crontab.

crontab принимает аргументы crontab(minute='', hour='', day_of_week='', day_of_month='', month_of_year='')
- minute - минута часа
- hour - час дня
- day_of_week - день недели
- day_of_mounth - день месяца
- month_of_year - месяц года
каждый из этих аргументов принимает специальные символы:
- * каждый отрезок minute=" * "  это как сказать: "каждую минуту"
- , список значений hour="1, 2, 3" как сказать: задача будет выполняться в 1 час ночи, 2 час ночи и 3 час ночиночи
- - диапазон minute="30 - 60" как сказать: задача будет выполняться с 30той минуты часа по 60 минуту часа
- / шаг minute="`*/2`" как сказать каждые 2 минуты

тут крайне важно уточнить одну деталь, время заменяеться не относительно запуска а относительно нуля то есть если мы напишем minute="`*/2`" и запустим программу в 16:05 то функция выполниться в 16:06 по тому что относительно 16:00, 16:06 подходит под каждые 2 минуты: 16:00, 16:02, 16:04, 16:06

вот как всё это может выглядить
```python
@app.on_after_configure.connect  
def setup_periodic_tasks(sender, **kwargs):  
    sender.add_periodic_task(
    crontab(  
        minute="*/2",  
        hour="2, 5, 3, 7, 12",  
        day_of_week="*/3"  
    ), hello.s(name="misha"))
```
тут описанно:
- каждую вторую минуту
- 2, 5, 3, 7, 12 часа дня 
- каждого третьего дня в неделю
вызывать функцию hello
